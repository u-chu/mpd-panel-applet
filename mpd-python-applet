#!/usr/bin/env python
# -*- coding: utf-8 -*-
#

#~ ./mpd-python-applet
import gi
gi.require_version("Gtk", "2.0")
#~ import pygtk, gtk, gobject
from gi.repository import Gtk as gtk
from gi.repository import MatePanelApplet
from gi.repository import GdkPixbuf
from gi.repository import GObject as gobject
from gi.repository import Notify as pynotify
import mpd
import time, os
from gettext import gettext as _
import gettext
import allbase
import plist, common, sres
import applet_settings

#~ import a

eb5=gtk.EventBox()
eb3=gtk.EventBox()
eb1=gtk.EventBox()
eb2=gtk.EventBox()
eb4=gtk.EventBox()
pb5=gtk.EventBox()
#~ from gi.repository import Notify

#~ import pygtk, sys, mateapplet, gtk, subprocess
#~ cl=gtk.Label("00:00:00  ")
#~ al=gtk.Label('  00:00:00  ')

def lb_click(w, e):
	if e.button==1:
		client = mpd.MPDClient()
		try:
			client.connect(common.addr, common.port)
		except:
			return
		n=client.status()		
		pbs=lb.allocation
		t=e.x/pbs.width*float(n['duration'])
		#~ print t, n
		client.seekcur(t)
		client.close()
		client.disconnect()
		#~ print pbs, t
	#~ print e,n
	
lb=gtk.ProgressBar()
pb5.add(lb)
pb5.connect('button_press_event', lb_click)
#~ lb.connect("clicked", lb_click)
lb.set_text("00:00:00/00:00:00")
lb.set_size_request(150,2)
pynotify.init(common.APP_IND)
notif=pynotify.Notification()
gettext.bindtextdomain(common.APP_IND+'.mo', common.DIR)
gettext.textdomain(common.APP_IND)

old_s=''
old_id=''
cur_s=''
cur_id=''
cur_stat=''
old_stat=''

def get_mpd_status():
	client = mpd.MPDClient()
	try:
	#if not isConnected(self):
		client.connect(common.addr, common.port)
	except:
		#~ print 3
		return ""
	s=client.status()['state']
	client.disconnect
	client.close()
	#~ print s
	return s
	
def get_mpd_current():
	client = mpd.MPDClient()
	try:
	#if not isConnected(self):
		client.connect(common.addr, common.port)
	except:
		#~ print 3
		return ""
	s=client.currentsong()
	client.disconnect
	client.close()
	#~ print s
	return s	
	
def mpd_check_status():
	global old_s
	global cur_s
	global old_stat
	#~ global eb5
	#~ global eb1
	#~ global eb4
	s=get_mpd_status()
	#~ if s=='pause':
	
	"""if s=='pause':
		eb5.hide()
		eb1.show()
		eb2.show()
		eb3.show()
	elif s=='stop':
		eb4.hide()
		eb5.hide()
		eb1.show()
		eb2.hide()
		eb3.hide()
	elif s=='play':
		eb1.hide()
		eb4.show()
		eb2.show()
		eb3.show()
		eb5.show()"""
			
	if s=='pause' or s=='play':
		t,p=get_mpd_pos()
		#~ print t,p
		lb.set_fraction(float(t)/float(p))
		lb.set_text('%s/%s'%(time.strftime("%H:%M:%S", time.gmtime(float(t))), time.strftime("%H:%M:%S", time.gmtime(float(p)))))
		cs=get_mpd_current()
		#~ {'album': 'Hammer of Justice', 'title': 'Beginning of the End', 'track': '1', 'duration': '251.454', 'artist': 'Thor', 'pos': '78', 'last-modified': '2019-04-26T02:04:56Z', 'albumartist': 'Thor', 'file': '--current/Thor - 2019 - Hammer of Justice/01 - Beginning of the End.mp3', 'time': '251', 'date': '2019', 'genre': 'Heavy Metal', 'id': '134'}
		cur_id=cs['id']
		cur_s=cs['file']
		#~ print cur_s, old_s		
		if (cur_s != old_s) or ((s != old_stat) and s != 'stop'):			
			title, album, artist, date=common.getrecords(cs)
			icon=gtk.STOCK_MEDIA_PLAY
			if os.path.exists(common.cdir+'/mpd.jpg'):
				icon=common.cdir+'mpd.jpg'
			title+=' ['+	time.strftime("%H:%M:%S", time.gmtime(float(p)))+']'
			message="%s\n<i>%s</i> (%s)\n<b><i>%s</i></b>"%(artist,album, date, get_mpd_status())
			notif.update(title, message, icon)
			notif.show()
			old_s=cur_s
			old_stat=s
	else:
			lb.set_fraction(0)
			lb.set_text("00:00:00/00:00:00")
	#~ print 'mpd_check_status'
	return True
	
gobject.timeout_add_seconds(1, mpd_check_status)
#~ gobject.idle_add(mpd_check_status)	
	
def get_mpd_pos():
	client = mpd.MPDClient()
	try:
	#if not isConnected(self):
		client.connect(common.addr, common.port)
	except:
		#~ print 3
		return ""
	#~ print 	client.status()
	p=client.status()['duration']
	t=client.status()['elapsed']
	client.disconnect
	client.close()
	#~ print s
	return t,p
	
def make_dialog(s1):
		dialog = gtk.MessageDialog(type=gtk.MessageType.QUESTION, buttons=gtk.ButtonsType.OK_CANCEL)
		entry = gtk.Entry()
		entry.set_text('darkology')
		dialog.set_markup(_('Searching for:'))
		db=dialog.get_content_area()
		db.pack_end(entry, False, False,0)
		dialog.set_title(s1)
		entry.connect("activate", lambda _: dialog.response(gtk.ResponseType.OK))
		dialog.set_default_response(gtk.ResponseType.OK)
		dialog.show_all()
		res=dialog.run()
		txt=entry.get_text().encode('utf-8')
		dialog.destroy()
		return [res, txt]
	
def fsearchdb(e):
	res, txt=make_dialog(_('Search in DB'))
	if res!=gtk.ResponseType.OK:
		return 2
	client=mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
	except:
		return 1
	rs=client.search('any',txt)
	plid=client.playlistid()
	cs=client.currentsong()
	#~ print cs
	if len(cs)>0:
		cid = cs['file']
	else:
		cid=''
	client.close()
	client.disconnect()
	if len(rs)<=0:
		d=gtk.MessageDialog(type=gtk.MessageType.ERROR, message_format='"%s" not found'%txt, buttons=gtk.ButtonsType.CLOSE)
		#d.connect("response", lambda *a: d.destroy())
		d.run()
		d.destroy()
		return 3
	sres.SRes(rs, plid, cid)
	#~ self.make_search_menu(rs)
	return 0
	#~ print rs
	#print Gtk.ResponseType.OK
	
	
def fplaylist(e):
	#~ print "fplaylist1"
	client = mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
	except:
		client.close()
		client.disconnect()
		#~ self.play_on_left_click(self)
		return	
	plid=client.playlistid()
	#print plid
	cid=''
	cs=client.currentsong()
	if len(cs)>0:
		cid = client.currentsong()['file']
	client.close()
	client.disconnect()
	if len(plid)<=0:
		return[None,0]
	#~ print "fplaylist2"	
	plist.PL(plid, cid)
	return 0
	
	
def applet_fill(applet):
	#~ global eb5
	#~ global eb1
	#~ global eb4
	p=applet.get_preferences_path()
	#~ print p
	hb=gtk.HBox()	
	b1=gtk.Image(stock=gtk.STOCK_MEDIA_PLAY)
	#~ eb1= 
	eb1.add(b1)
	eb1.connect('button-release-event', fplay)	
	b2=gtk.Image(stock=gtk.STOCK_MEDIA_NEXT)
	#~ eb2=gtk.EventBox()
	eb2.add(b2)
	eb2.connect('button-release-event', fnext)
	b3=gtk.Image(stock=gtk.STOCK_MEDIA_PREVIOUS)
	#~ eb3=gtk.EventBox()
	eb3.add(b3)
	eb3.connect('button-release-event', fprev)
	b4=gtk.Image(stock=gtk.STOCK_MEDIA_STOP)
	#~ eb4=gtk.EventBox()
	eb4.add(b4)
	eb4.connect('button-release-event', fstop)
	b5=gtk.Image(stock=gtk.STOCK_MEDIA_PAUSE)
	#~ eb5=gtk.EventBox()
	eb5.add(b5)
	eb5.connect('button-release-event', fpause)
	
	#~ s=get_mpd_status()
	#~ print s

	#~ elif s=='stop':
		#~ b4.set_visible_window(False)
		#~ b5.set_visible_window(False)
	#~ elif s=='play':
		#~ b1.set_visible_window(False)
	
	#~ s=get_mpd_status()

	#~ hb.pack_start(cl, False, False, 0)
	hb.pack_start(pb5, False, False, 0)
	#~ hb.pack_start(al, False, False, 0)
	hb.pack_start(gtk.Label('  '), False, False, 0)
	hb.pack_start(eb3, False, False, 0)
	hb.pack_start(eb4, False, False, 0)
	hb.pack_start(eb5, False, False, 0)
	hb.pack_start(eb1, False, False, 0)
	hb.pack_end(eb2, False, False, 0)
	applet.add(hb)
	
	#~ <menuitem name="Play/Pause" action="Play/Pause" />
	acts=[
	("fprev1", gtk.STOCK_MEDIA_PREVIOUS, _("Previous"), None, None, fprev1),
	("fpause", gtk.STOCK_MEDIA_PAUSE, _("Pause"), None, None, fpause),
	("fstop1", gtk.STOCK_MEDIA_STOP,_("Stop"), None, None, fstop1),
	("fplay1", gtk.STOCK_MEDIA_PLAY,_("Play"), None, None, fstop1),
	("fnext1", gtk.STOCK_MEDIA_NEXT,_("Next") , None, None, fplay),
	("fsettings", gtk.STOCK_PROPERTIES, _("Settings"), None, None, fsettings),
	("fsearchdb", gtk.STOCK_FIND, _("Search in DB"), None, None, fsearchdb),
	('fplaylist', None, _('Playlist'), None, None, fplaylist),
	('fdb', None, _('DB'), None, None, fdb),
	]
	propxml="""
			<menuitem name="fprev1" action="fprev1" />			
			<menuitem name="fstop1" action="fstop1" />
			<menuitem name="fpause" action="fpause" />
			<menuitem name="fplay1" action="fplay1" />
			<menuitem name="fnext1" action="fnext1" />
			<separator />
			<menuitem name="fplaylist" action="fplaylist" />
			<menuitem name="fdb" action="fdb" />
			
			<menuitem name="fsearchdb" action="fsearchdb"/>
			<separator />
			<menuitem name="fsettings" action="fsettings" />
			"""
			 #~ action="Search%20in%20DB" />
	#~ verbs = [("About", showAboutDialog)]
	#~ name, stock_id, label, accellerator, tooltip, callback
	mpd_check_status()
	
	ag=gtk.ActionGroup.new("mpd_ag")
	ag.add_actions(acts, None)
	#~ verbs = [("About", ''), ('Close',''), ('Next',''),('Previous',''), ('Play',''), ('Stop', ''), ('Pause', ''), ('Settings', '')]
	applet.setup_menu(propxml, ag)
	applet.show_all()
	#~ _IdleObject.__init__(None)
	#~ return True

def fsettings(e):
	pass
	
def fdb(e):
	allbase.DB()
	
def fpause (s, e):
	client = mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
	except:
		client.close()
		client.disconnect()
		#~ self.play_on_left_click(self)
		return	
	status=client.status()['state']
	if status=='pause':
		client.play()
		#~ self.ind.set_from_stock(gtk.STOCK_MEDIA_PLAY)
	elif status=='play':
		client.pause()
		#~ self.ind.set_from_stock(gtk.STOCK_MEDIA_PAUSE)
		#~ exit_item.set_image(gtk.STOCK_QUIT,22))
	client.close()
	client.disconnect()
	
def fplay1(e):
	fplay(None, e)
	
def fplay (s, e):
	client = mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
	except:
		client.close()
		client.disconnect()
		#~ self.play_on_left_click(self)
		return	
	status=client.status()['state']
	if status=='pause' or status=='stop':
		client.play()
		#~ self.ind.set_from_stock(gtk.STOCK_MEDIA_PLAY)
	elif status=='play':
		client.pause()
		#~ self.ind.set_from_stock(gtk.STOCK_MEDIA_PAUSE)
		#~ exit_item.set_image(gtk.STOCK_QUIT,22))
	client.close()
	client.disconnect()
	
def fnext1(n):
	fnext(None, n)
	
def fnext(s, n):
	client = mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
	except:
		return
	if client.status()['state']=='stop':
		client.close()
		client.disconnect()
		return
	client.next()
	client.close()
	client.disconnect()
	
def fprev1(n):
	fprev(None, n)	
	
def fprev(s, n):
	client = mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
	except:
		return
	if client.status()['state']=='stop':
		client.close()
		client.disconnect()
		return
	client.previous()
	client.close()
	client.disconnect()
	
def fstop1(n):
	fstop(None, n)
	
def fstop(s, n):
	client = mpd.MPDClient()
	try:
		client.connect(common.addr, common.port)
		client.stop()
		client.close()
		client.disconnect()	
	except:
		pass
		
def factory(applet, iid, data):
	#~ if iid != "MpdPythonAppletFactory":
		#~ print 1
		#~ return False
	global old_s
	global cur_s
	global cur_stat
	global old_stat
	old_s=''
	cur_s=''
	cur_stat=''
	old_stat=''
	applet_fill(applet)
	return True		
	
	
def showAboutDialog(*arguments, **keywords):
	pass
	#~ subprocess.call("mate-about")

MatePanelApplet.Applet.factory_main("MpdPythonAppletFactory", True,
                                    MatePanelApplet.Applet.__gtype__,
                                    factory, None)
